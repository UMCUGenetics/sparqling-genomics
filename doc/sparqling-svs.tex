\documentclass[11pt,a4paper,oneside]{book}
\usepackage{umcu}
\title{SPARQLing structural variation}
\author{Roel Janssen}

\begin{document}

\begin{titlepage}
  \topskip0pt
  \vspace*{\fill}
  \begin{center}
    \rule{\textwidth}{1.0pt}~\\~\\
    \Huge SPARQLing structural variation
    \rule{\textwidth}{1.0pt}
    \Large Roel Janssen~\\~\\
    \large September 2017
    % Put it a little bit above the center of the page.
    ~\\~\\~\\~\\~\\~\\~\\~\\~\\~\\~\\~\\~\\~\\
  \end{center}
  \topskip0pt
  \vspace*{\fill}

  \thispagestyle{empty}
\end{titlepage}

\setcounter{page}{1}
\pagenumbering{roman}
\hypersetup{linkcolor=black}
\tableofcontents
\newpage{}
\hypersetup{linkcolor=LinkGray}
\setcounter{page}{1}
\pagenumbering{arabic}

\input{introduction}

\chapter{Command-line programs}

  The project provides programs to create a complete pipeline including
  data conversion, data importing and data exploration.  The tasks we can
  perform with the command-line programs are:
  \begin{itemize}
    \item Extract triples from VCF files;
    \item Push data to a SPARQL endpoint.
  \end{itemize}

\section{Preparing data with \texttt{vcf2turtle}}
\label{sec:vcf2turtle}

  Obtaining variants from sequenced data is a task of so called
  \emph{variant callers}.  These programs output the variants they found in
  the \emph{Variant Call Format} (VCF).  Before we can use the data described
  in this format, we need to extract triples from it.

  The \texttt{vcf2turtle} program does exactly this, by converting a VCF file
  into the \emph{Terse RDF Triple Language} (Turtle) format.  In section
  \ref{sec:curl} {\color{LinkGray}`\nameref{sec:curl}%
  '} we describe how to import the data produced by \texttt{vcf2turtle} in the
  database.

\subsection{Data extracted by \texttt{vcf2turtle}}

  The triples \texttt{vcf2turtle} extracts are:
  \begin{itemize}
    \item The base fields: \texttt{CHROM}, \texttt{POS}, \texttt{ID},
      \texttt{ALT}, \texttt{REF}, \texttt{QUAL}, and \texttt{FILTER}.
    \item Optionally, when present: \texttt{SVTYPE}, \texttt{END},
      \texttt{SVLEN}, \texttt{CIPOS}, \texttt{CIEND}, \texttt{MAPQ},
      \texttt{PE}, \texttt{SR}, \texttt{SRQ}, \texttt{RC}, \texttt{DR},
      \texttt{DV}, \texttt{RR}, \texttt{RV}.
  \end{itemize}

\subsection{How \texttt{vcf2turtle} describes variants}

  The program uses the \emph{Sequence Manipulation Ontology} (SMO)\cite{unknown},
  and the \emph{Feature Annotation Location Description Ontology} (FALDO)%
  \cite{unknown}.  We will use the sequence from figure \ref{fig:sequence} as
  an example to explain how variants are described by \texttt{vcf2turtle}.

\begin{figure}[H]
  \begin{center}
    \includegraphics[height=4cm]{figures/sequence.pdf}
    \caption{\small Figure for demonstrating variant types.}
    \label{fig:sequence}
  \end{center}
\end{figure}

\subsection{Example usage}

\begin{siderules}
\begin{verbatim}
vcf2turtle --input-file=/path/to/my/variants.vcf > /path/to/my/variants.ttl
\end{verbatim}
\end{siderules}

\subsection{Run-time properties}

  The program typically uses less than eight megabytes of memory, because it
  processes the variant calls one-by-one.  It reads through the file from top
  to bottom, so its running time is dependent on the input file size.  The
  throughput of this program is around $20$ to $60$ megabytes per second,
  depending on your computer.

\section{Importing data with \texttt{curl}}
\label{sec:curl}

  To import data in the \emph{Terse RDF Triple Language} (Turtle) format in
  a triple store (our database), we can use \texttt{curl}.

  The triple stores typically store data in \emph{graphs}.  One triple store
  can host multiple graphs, so we must tell the triple store which graph we
  would like to add the data to.

\subsection{Example usage}

\begin{siderules}
\begin{verbatim}
curl -X POST                                                 \
     -H Content-Type:text/turtle                             \
     -T /path/to/variants.ttl                                \
     -G <endpoint URL>                                       \
     --digest -u <username>:<password>                       \
     --data-urlencode graph=http://destination:8890/Example/
\end{verbatim}
\end{siderules}

\chapter{Web interface}
\label{chap:web-interface}

  In addition to the command-line programs, the project provides a web
  interface for prototyping queries, and quick data reporting.  With the
  web interface you can:
  \begin{itemize}
  \item Write and execute SPARQL queries;
  \item Import and export data;
  \item Visualize triple patterns;
  \item View database statistics.
  \end{itemize}

\section{Running the web interface}

  The web interface can be started using the following command:

\begin{siderules}
\begin{verbatim}
web/run
\end{verbatim}
\end{siderules}

  By default, it will be available on \url{http://localhost:5000}.

\section{Prototyping SPARQL queries}

\section{Accessing non-local graphs}

\chapter{Information retrieval with SPARQL}

  In section \ref{sec:vcf2turtle} {\color{LinkGray}`%
  \nameref{sec:vcf2turtle}'} we discussed how to extract
  triples from common data formats.  In section \ref{sec:curl}
  {\color{LinkGray}`\nameref{sec:curl}'} we discussed how we could insert
  those triples into a SPARQL endpoint.

  In this section, we will start exploring the inserted data by using the
  query language called \emph{SPARQL}.  Understanding SPARQL will be crucial
  for the integration in your own programs or scripts --- something we will
  discuss in chapter \ref{chap:programming}
  {\color{LinkGray}`\nameref{chap:programming}'}.

  The queries in the remainder of this chapter can be readily copy/pasted into
  the query editor of the web interface (see chapter \ref{chap:web-interface}
  {\color{LinkGray}`\nameref{chap:web-interface}'}).

\section{Local querying}

  The promise from ``linked data'' is to make data available in such a way that
  one query can retrieve information from multiple SPARQL endpoints.  We call
  querying over multiple SPARQL endpoints \emph{federated querying}.  But before
  we do that, let's look at simple queries that only look at our own data.

\subsection{Retrieving all structural variants}
\begin{siderules}
\begin{verbatim}
PREFIX : <http://localhost:8890/TestGraph/>

SELECT ?variant
WHERE {
  ?variant a :StructuralVariant .
}
\end{verbatim} 
\end{siderules}

\subsection{Retrieving information about structural variants}
\label{sec:sparqling-svs}

\begin{siderules}
\begin{verbatim}
PREFIX : <http://localhost:8890/TestGraph/>

SELECT ?variant ?chromosome ?position ?filter ?quality
WHERE {
  ?variant a :StructuralVariant .
  ?variant :quality ?quality .
  ?variant :genome_position ?p .
  ?variant :filter ?filter .
  ?p :chromosome ?chromosome .
  ?p :position ?position .
}
\end{verbatim}
\end{siderules}

\subsection{Counting structural variants}

\begin{siderules}
\begin{verbatim}
PREFIX : <http://localhost:8890/TestGraph/>

SELECT COUNT(?variant) as ?numberOfVariants
WHERE {
  ?variant a :Variant .
}
\end{verbatim}
\end{siderules}

\subsection{Filtering structural variants}

\begin{siderules}
\begin{verbatim}
PREFIX : <http://localhost:8890/TestGraph/>

SELECT ?variant ?type ?quality ?chromosome ?position
WHERE {
  ?variant a :StructuralVariant .
  ?variant :quality ?quality .
  ?variant :genome_position ?p .
  ?variant :type ?type .
  ?p :chromosome ?chromosome .
  ?p :position ?position .

  FILTER (?position > 80000)
  FILTER (?position < 90000)
  FILTER (?chromosome = "X")
  FILTER (?type = "DEL")
}
\end{verbatim}
\end{siderules}

\subsection{Sorting}

\begin{siderules}
\begin{verbatim}
PREFIX : <http://localhost:8890/TestGraph/>

SELECT ?variant ?chromosome ?position ?quality ?filter
WHERE {
  ?variant a :SNPVariant .
  ?variant :genome_position ?p .
  ?p :chromosome ?chromosome .
  ?p :position ?position .
  ?variant :quality ?quality .
  ?variant :filter ?filter .
  FILTER (?filter = "PASS")
}
ORDER BY ?chromosome DESC(?quality)
\end{verbatim}
\end{siderules}

\subsection{More advanced filtering}

\begin{siderules}
\begin{verbatim}
PREFIX : <http://localhost:8890/TestGraph/>

SELECT ?variant ?quality ?chromosome ?filter
WHERE {
  ?variant a :StructuralVariant .
  ?variant :quality ?quality .
  ?variant :genome_position ?p .
  ?variant :filter ?filter .
  ?variant :genome_position ?p .
  ?p :chromosome ?chromosome .
  ?p :position ?position .

  FILTER (?quality < 0)
  FILTER (?filter != "PASS" 
          AND ?filter != "MinSomaticScore"
          AND ?filter != "MaxDepth")
}
ORDER BY ?chromosome
LIMIT 250
\end{verbatim}
\end{siderules}

\subsection{Basic arithmetics and combining properties}

\begin{siderules}
\begin{verbatim}
PREFIX : <http://localhost:8890/TestGraph/>

SELECT ?variant ?quality ?chromosome ?filter ?confidenceInterval
WHERE {
  ?variant a :StructuralVariant .
  ?variant :quality ?quality .
  ?variant :filter ?filter .
  ?variant :genome_position ?p .
  ?p :confidence_interval_start ?cistart .
  ?p :confidence_interval_end ?ciend .
  ?p :chromosome ?chromosome .
  ?p :position ?position .

  FILTER (?filter = "PASS")
  FILTER (?chromosome > 3)
  BIND( ABS(?cistart) + ABS(?ciend) AS ?confidenceInterval)
}
ORDER BY ?chromosome
LIMIT 250
\end{verbatim}
\end{siderules}

\subsection{Patterns with optional matches}
\begin{siderules}
\begin{verbatim}
PREFIX : <http://localhost:8890/TestGraph/>

SELECT ?variant ?type ?cistart ?ciend
WHERE {
  ?variant a :StructuralVariant .
  ?variant :quality ?quality .
  ?variant :type ?type .
  ?variant :filter ?filter .
  ?variant :genome_position ?p .
  ?p :chromosome ?chromosome .
  ?p :position ?position .

  OPTIONAL {
    ?p :confidence_interval_start ?cistart .
    ?p :confidence_interval_end ?ciend .
  }
}
\end{verbatim}
\end{siderules}

\section{Federated querying}

  Now that we've seen local queries, there's only one more construct we need to
  know about to combine this with remote SPARQL endpoints: the \texttt{SERVICE}
  construct.
  
\subsection{Get an overview of Biomodels (from ENSEMBL)}
\begin{siderules}
\begin{verbatim}
PREFIX sbmlrdf: <http://identifiers.org/biomodels.vocabulary#>
PREFIX sbmldb: <http://identifiers.org/biomodels.db/>

SELECT ?speciesId ?name {
  SERVICE <http://www.ebi.ac.uk/rdf/services/sparql/> {
    sbmldb:BIOMD0000000001 sbmlrdf:species ?speciesId .
    ?speciesId sbmlrdf:name ?name
  }
}
\end{verbatim}
\end{siderules}

\subsection{Get all genes in a region (from ENSEMBL)}
\begin{siderules}
\begin{verbatim}
PREFIX grch38: <http://rdf.ebi.ac.uk/resource/ensembl/89/homo_sapiens/GRCh38/>
PREFIX faldo: <http://biohackathon.org/resource/faldo#>
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>

SELECT DISTINCT ?gene ?ensemblGeneId ?geneType 
                ?location ?begin ?beginPosition 
                ?end ?endPosition {
    ?location faldo:reference grch38:10 .
    ?location faldo:begin ?begin .
    ?location faldo:end ?end .
    ?begin faldo:position ?beginPosition .
    ?end faldo:position ?endPosition .
    ?ensemblGeneId a ?type ;
          rdfs:label ?label ;
          dc:description ?desc ;
          dc:identifier ?id ;
          faldo:location ?location .
    ?type rdfs:label ?geneType .
    ?ensemblGeneId rdfs:label ?gene .
}
LIMIT 10
\end{verbatim}
\end{siderules}

%% \begin{siderules}
%% \begin{verbatim}

%% \end{verbatim}
%% \end{siderules}

\section{Schema reference}

  In section \ref{sec:sparqling-svs} {\color{LinkGray}`%
  \nameref{sec:sparqling-svs}'}, we used various triple patterns like:

\begin{siderules}
\begin{verbatim}
?variant :genome_position ?p
\end{verbatim}
\end{siderules}

  Where does the \texttt{:genome\_position} property come from?  And are
  there more properties available that we haven't seen yet?

  The schema that describes what can be described is called an \emph{ontology}.
  The triples that the \texttt{vcf2turtle} program outputs are described in
  the \emph{close-to-home} ontology.  In table \ref{table:close-to-home}, a
  complete description of the \emph{close-to-home} ontology can be found.

  \hypersetup{urlcolor=black}
  \begin{table}[H]
    \begin{tabularx}{\textwidth}{ l l l L }
      \headrow
      \textbf{Subject} & \textbf{Predicate} & \textbf{Object}
      & \textbf{Description}\\
      \evenrow
      :Variant & rdf:type & owl:Class
      & \texttt{:Variant} is used as an identifier for describing a variant .\\
      \oddrow
      :GenomePosition & rdf:type & owl:Class
      & \texttt{:GenomePosition} is used to describe the position when mapped
      to a reference genome.\\
    \end{tabularx}
    \caption{\small The triple patterns described by \texttt{vcf2turtle}.}
    \label{table:close-to-home}
  \end{table}
  \hypersetup{urlcolor=LinkGray}

\chapter{Programming in Python, Perl, R, Scheme, C, and/or C++}
\label{chap:programming}

\section{Using SPARQL with R}
\label{sec:sparql-with-r}

  Before we can start, we need to install the \texttt{SPARQL} package from
  \href{https://cran.r-project.org/web/packages/SPARQL/index.html}{CRAN}.

\begin{siderules}
\begin{verbatim}
install.packages('SPARQL')
\end{verbatim}
\end{siderules}

  Once we're set up, we can query like so:

\begin{siderules}
\begin{verbatim}
# Load the library
library('SPARQL')

# Define the endpoint to query.
endpoint <- "http://localhost:8890/sparql"

# Define the actual query to run.
query <- "PREFIX : <http://localhost:5000/cth/>
PREFIX ref: <http://rdf.ebi.ac.uk/resource/ensembl/90/homo_sapiens/GRCh38/>
PREFIX faldo: <http://biohackathon.org/resource/faldo#>
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>

SELECT DISTINCT ?variant ?svtype ?geneName ?ensemblGeneId ?location {
    ?variant       rdf:type            :StructuralVariant ;
                   :genome_position    ?p ;
                   :filter             ?filter ;
                   :type               ?svtype .
    ?p             :chromosome         ?chromosome ;
                   :position           ?position .
    ?location      faldo:reference     ref:1 ;
                   faldo:begin         ?begin ;
                   faldo:end           ?end .
    ?begin         faldo:position      ?beginPosition .
    ?end           faldo:position      ?endPosition .
    ?ensemblGeneId rdf:type            ?type ;
                   faldo:location      ?location ;
                   rdfs:label          ?geneName .
    FILTER (?chromosome = \"1\")
    FILTER (?position > (?beginPosition) && ?position < (?endPosition))
}
LIMIT 10";

# Run the query
query_data <- SPARQL (endpoint, query)

# Put the results (a data frame) in a separate variable.
query_results <- query_data$results
\end{verbatim}
\end{siderules}

Additional examples can be found in the \texttt{tools/SVPlot/R} directory.

\input{performance-tuning}

\end{document}
