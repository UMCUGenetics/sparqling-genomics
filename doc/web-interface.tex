\chapter{Web interface}
\label{chap:web-interface}

  In addition to the command-line programs, the project provides a web
  interface for prototyping queries, and quick data reporting.  With the
  web interface you can:
  \begin{itemize}
  \item Write and execute SPARQL queries;
  \item Collaborate within ``projects'';
  \item Browse available datasets;
  \item Explore the inner-structure of datasets.
  \end{itemize}

\section{Configuring the web interface}
\label{sec:configuring-sg-web}

  Before the web interface can be started, a few parameters have to be
  configured.  This is done through an XML file.  The following example
  displays all options, except for the authentication part, which is
  discussed separately in section \ref{sec:authentication}
  {\color{LinkGray}`\nameref{sec:authentication}'}.

\begin{siderules}
\begin{verbatim}
<?xml version="1.0" encoding="utf-8"?>
<web-interface>
  <fork>0</fork>
  <bind-address>127.0.0.1</bind-address>
  <port>8080</port>
  <authentication>
    <!-- Either LDAP settings, or single-user authentication -->
  </authentication>
</web-interface>
\end{verbatim}
\end{siderules}

\subsection{To fork or not to fork}

  The \texttt{fork} property can be either \texttt{0} to keep the
  \texttt{sg-web} process in the foreground of your shell, or
  \texttt{1} to run the \texttt{sg-web} process as a daemon.

\subsection{Bind address and port}

  Because web services are popular these days, \texttt{sg-web} can be configured
  to bind on an arbitrary address and an arbitrary port.

\subsection{System connection}

  The web interface stores its own information as RDF.  Therefore it needs
  a connection to an RDF store where it can write to the graphs described
  in table \ref{table:writable-graphs}.

  \hypersetup{urlcolor=black}
  \begin{table}[H]
    \begin{tabularx}{\textwidth}{l!{\VRule[-1pt]}X}
      \headrow
      \textbf{Graph} & \textbf{Reason}\\
      \evenrow
      \texttt{http://sparqling-genomics.org/sg-web/state}
      & In this graph, queries and projects are stored.\\
      \oddrow
      \texttt{http://sparqling-genomics.org/sg-web/cache}
      & This graph is used to speed up the web interface by
      pre-running various SPARQL queries.\\
    \end{tabularx}
    \caption{\small Graphs that need to be writable for the web interface.}
    \label{table:writable-graphs}
  \end{table}
  \hypersetup{urlcolor=LinkGray}

\subsubsection{System connection example}

  To configure the \emph{system connection}, two parameters need to be
  specified: \texttt{uri}, and \texttt{backend}.  Additionally, when the
  RDF store requires authentication for writing to it, a \texttt{username}
  and a \texttt{password} can be provided.

  The following example shows how to configure the \emph{system connection}:

\begin{siderules}
\begin{verbatim}
<?xml version="1.0" encoding="utf-8"?>
<web-interface>
  ...
  <system-connection>
    <uri>http://localhost:8890/sparql-auth</uri>
    <backend>virtuoso</backend>
    <username>dba</username>
    <password>dba</password>
  </system-connection>
</web-interface>
\end{verbatim}
\end{siderules}

\subsection{Authentication}
\label{sec:authentication}

  There are two ways to configure authentication.  For single-user deployments
  or environments that lack an LDAP service, a preconfigured username and
  password can be set.  For a multi-user deployment, the web interface can be
  configured to use an LDAP server.

\subsubsection{Single-user configuration}

  The simplest form of authentication is the ``single-user configuration''.
  Configuring it involves providing a username and the SHA256 sum of a password.
  The following example shows how to configure ``single-user authentication'':

\begin{siderules}
\begin{verbatim}
<?xml version="1.0" encoding="utf-8"?>
<web-interface>
  ...
  <authentication>
    <single-user>
      <username>user</username>
      <!-- The password field must contain the SHA256 sum of the
           plaintext password -->
      <password>9f86d08...0f00a08</password>
    </single-user>>
  </authentication>
</web-interface>
\end{verbatim}
\end{siderules}

\subsubsection{LDAP authentication example}

  To configure LDAP, three parameters must be specified: the URI to the LDAP
  service (1), the ``organizational unit'' (2), and the ``domain'' (3).  The
  username is used as the ``common name''.

  The following example shows how to configure LDAP authentication:

\begin{siderules}
\begin{verbatim}
<?xml version="1.0" encoding="utf-8"?>
<web-interface>
  ...
  <authentication>
    <ldap>
      <uri>ldap://example.local</uri>
      <organizational-unit>People</organizational-unit>
      <domain>department.organization.tld</domain>
    </ldap>
  </authentication>
</web-interface>
\end{verbatim}
\end{siderules}

\section{Running the web interface}

  The web interface can be started using the \texttt{sg-web} command:

\begin{siderules}
\begin{verbatim}
sg-web --configuration-file=file.xml
\end{verbatim}
\end{siderules}

  $\ldots{}$ where \texttt{file.xml} is a configuration file as
  discussed in section \ref{sec:configuring-sg-web}
  {\color{LinkGray}`\nameref{sec:configuring-sg-web}'}.

\section{Configuring connections}
\label{sec:configure-connections}

  The first useful step is to configure a connection to a SPARQL endpoint.

  \begin{figure}[h]
    \begin{center}
      \includegraphics[width=1.0\textwidth]{figures/web-connections.png}
    \end{center}
    \caption{The \emph{connections} page enables users to configure accessible
      SPARQL endpoints.  Adding a connection here will provide an option to
      query it on the \emph{query} page.}
    \label{fig:web-connections}
  \end{figure}

\section{Managing projects}

  Projects are a loosely-defined way to group queries and to collaborate with
  other users.  Projects provide a way to manage access to \emph{graphs}, and
  to share previously-executed queries among project members.

  Marking a project as ``active'' indicates that queries executed using the web
  interface relate to that project.  See also section \ref{sec:query-history}
  {\color{LinkGray}`\nameref{sec:query-history}'}.

\section{Executing queries}

  After configuring at least one endpoint, it can be chosen on the \emph{query}
  page to execute a query against it.

  \begin{figure}[h]
    \begin{center}
      \includegraphics[width=1.0\textwidth]{figures/web-query.png}
    \end{center}
    \caption{The \emph{query} page enables users to execute a query against a
      SPARQL endpoint.  The connections configured at the \emph{connections} page
      can be chosen from the drop-down menu.}
    \label{fig:web-query}
  \end{figure}

\subsection{Query history}
\label{sec:query-history}

  When prototyping SPARQL queries, better known as ``SPARQLing around'', it's
  good to know that all queries that yielded a result are stored in the
  \emph{query history}.  The history is shown on the \emph{query} page below the
  query editor.

  Each \emph{project} has its own query history, and newly executed queries are
  added to the current \emph{active} project.

\section{Explore graphs with the Exploratory}

  Another utility aimed at SPARQLing around faster is the \emph{exploratory}.

  \begin{figure}[h]
    \begin{center}
      \includegraphics[width=1.0\textwidth]{figures/web-exploratory.png}
    \end{center}
    \caption{The \emph{exploratory} page enables users to learn about the
      structure of the triplets in a graph.}
    \label{fig:web-exploratory}
  \end{figure}

  The exploratory uses a common pattern in RDF to help writing queries.  Its
  interface provides a four-step selection process to find \emph{predicates}
  associated with an \texttt{rdf:type}.  The programs described in chapter
  \ref{chap:command-line} {\color{LinkGray}`\nameref{chap:command-line}'}
  automatically add the \texttt{rdf:type} annotations.

\subsection{Connections and graphs}

  The first step in finding predicates involves choosing a connection
  (see section \ref{sec:configure-connections} {\color{LinkGray}%
    `\nameref{sec:configure-connections}'}).  The second step involves
  choosing a graph.  If the connection does not support the use of graphs,
  the journey ends here.

\subsection{Types}

  The third step looks for triplets that match the pattern \emph{subject}
  $\rightarrow$ \texttt{rdf:type} $\rightarrow$ \emph{type}.  All matches for
  \emph{type} are displayed.  For data imported with \texttt{vcf2rdf} (see
  section \ref{sec:vcf2rdf} {\color{LinkGray}`\nameref{sec:vcf2rdf}'}), this
  will display (among other types) the \texttt{VariantCall} type.

\subsection{Predicates}

  Staying with the \texttt{VariantCall} example;  All data properties extracted
  from a VCF file can be found under this type.  A predicate displayed in this
  column occurs in \emph{at least} one triplet.  It not necessarily occurs in
  \emph{every} triplet.  Especially when using \texttt{INFO} and \texttt{FORMAT}
  fields in a VCF file, we recommend using them in a query inside an
  \texttt{OPTIONAL} clause.

\section{Programmatic access to the web interface's functionality}

  Other than a user interface, the web interface provides a machine interface
  that supports JSON, and S-expressions.  The remainder of this section
  describes the API.

  Whenever applicable, data can be send or returned in the various formats.
  Table \ref{table:api-return-formats} provides an overview of supported formats.

  \hypersetup{urlcolor=black}
  \begin{table}[H]
    \begin{tabularx}{\textwidth}{l!{\VRule[-1pt]}X}
      \headrow
      \textbf{Content-Type} & \textbf{Example response}\\
      \evenrow
      \texttt{application/json}
      & \texttt{[\{ "message": "This is a JSON response." \}]}\\
      \oddrow
      \texttt{application/xml}
      & \texttt{<message>This is a XML response.</message>}\\
      \evenrow
      \texttt{application/s-expression}
      & \texttt{("This is a S-expression response.")}\\
    \end{tabularx}
    \caption{\small Implemented content types for the API.  The
      \texttt{Content-Type} can be used in the \texttt{Accept} HTTP header.}
    \label{table:api-return-formats}
  \end{table}
  \hypersetup{urlcolor=LinkGray}

\subsection{Formatting \texttt{POST} requests}

  The \texttt{Accept} parameter influences the response format of the API,
  and the \texttt{Content-Type} parameter can be used to indicate the format
  of the request.

  In addition to the documented \texttt{Content-Type} values, the type
  \texttt{application/x-www-form-urlencoded} is also allowed, which expects
  the following format:
\begin{siderules}
\begin{verbatim}
parameter1=value1&parameter2=value2&...
\end{verbatim}
\end{siderules}

\subsection{Conventions when using XML}

\begin{sloppypar}
  To format the request in the XML format, the API expects
  parameters to be wrapped in \texttt{<parameters>...</parameters>} elements.
\end{sloppypar}
  So, to log in using an XML request, the following message will be accepted:

\begin{siderules}
\begin{verbatim}
POST /api/login HTTP/1.1
Host: ...
Content-Type: application/xml
Content-Length: 88
Connection: close

<parameters>
 <username>...</username>
 <password>...</password>
</parameters>
\end{verbatim}
\end{siderules}

  Subsequently, when \texttt{Accept}ing XML the results are wrapped in
  \texttt{<results>...</results>}, and data structures built from multiple
  key-value pairs are wrapped in \texttt{<result>...<result>}.  The
  following example illustrates how that looks:

\begin{siderules}
\begin{verbatim}
GET /api/projects HTTP/1.1
Host: ...
Accept: application/xml
Cookie: ...
Connection: close

<results>
  <result>
    <projectId>http://sparqling-genomics.org/0.99.10/Project/...</projectId>
    <creator>http://sparqling-genomics.org/0.99.10/Agent/...</creator>
    ...
  </result>
</results>
\end{verbatim}
\end{siderules}

\textbf{Note}: The actual response strips the whitespace.  It was added to
this example for clarity.

\subsection{\texttt{/api/login}: Authenticating API requests}
\label{sec:api-login}

  Before being able to interact with the API, a session token must be obtained.
  This can be done by sending a \texttt{POST}-request to \texttt{/api/login},
  with the following parameters:
  \begin{itemize}
    \item{\texttt{username}}
    \item{\texttt{password}}
  \end{itemize}

  The response contains a cookie with the session token.  Use this cookie in
  subsequent requests to stay logged in.

  When authentication fails, the service will respond with HTTP status-code
  \texttt{401}.

\subsection{\texttt{/api/projects}: Listing projects}

  Retrieving a list of projects can be done by sending a \texttt{GET} request
  to \texttt{/api/projects}.  Don't forget to include the session token cookie
  obtained in section \ref{sec:api-login} {\color{LinkGray}`%
    \nameref{sec:api-login}'}.

  Use the \texttt{Accept} header to choose the format of the response.

\subsection{\texttt{/api/assign-graph}: Add a graph to a project.}

  Assigning a graph to a project can be done by sending a \texttt{POST} request
  to \texttt{/api/assign-graph}.  The required parameters are:

  \begin{itemize}
    \item{\texttt{project-uri}: This can be obtained from a call to
      \texttt{/api/projects}.}
    \item{\texttt{graph-uri}: The graph URI to assign.}
  \end{itemize}

  The following example based on cURL shows how to perform the request:
\begin{siderules}
\begin{verbatim}
curl -X POST                                               \
     -H "Accept: application/json"                         \
     -H "Content-Type: application/json"                   \
     --cookie "SGSession=..."                              \
     --data '{ "project-uri": "http://the-project-uri",    \
               "graph-uri": "http://the-new-graph-name" }' \
     http://localhost/api/assign-graph
\end{verbatim}
\end{siderules}

\subsection{\texttt{/api/unassign-graph}: Remove a graph from a project.}

  Like assigning a graph to a project, it can be unassigned as well using
  \texttt{/api/unassign-graph} using the same parameters as
  \texttt{/api/assign-graph}.

  The following example based on cURL shows how to perform the request:
\begin{siderules}
\begin{verbatim}
curl -X POST                                               \
     -H "Accept: application/json"                         \
     -H "Content-Type: application/json"                   \
     --cookie "SGSession=..."                              \
     --data '{ "project-uri": "http://the-project-uri",    \
               "graph-uri": "http://the-new-graph-name" }' \
     http://localhost/api/unassign-graph
\end{verbatim}
\end{siderules}
