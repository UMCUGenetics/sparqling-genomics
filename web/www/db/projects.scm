;;; Copyright © 2018  Roel Janssen <roel@gnu.org>
;;;
;;; This program is free software: you can redistribute it and/or
;;; modify it under the terms of the GNU Affero General Public License
;;; as published by the Free Software Foundation, either version 3 of
;;; the License, or (at your option) any later version.
;;;
;;; This program is distributed in the hope that it will be useful,
;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
;;; Affero General Public License for more details.
;;;
;;; You should have received a copy of the GNU Affero General Public
;;; License along with this program.  If not, see
;;; <http://www.gnu.org/licenses/>.

(define-module (www db projects)
  #:use-module (www util)
  #:use-module (www config)
  #:use-module (sparql lang)
  #:use-module (ice-9 format)
  #:use-module (ice-9 receive)
  #:use-module (ice-9 rdelim)
  #:use-module (srfi srfi-1)
  #:use-module (srfi srfi-9)

  #:export (project-add
            project-edit
            project-remove
            project-is-active?
            active-project
            all-projects
            project-by-name
            load-projects
            persist-projects

            alist->project
            project->alist
            project->ntriples

            make-project
            project-name
            project-samples
            project?

            set-project-name!
            set-project-samples!
            project-set-as-active!))

;; PROJECT RECORD TYPE
;; ----------------------------------------------------------------------------
(define-record-type <project>
  (make-project is-active? name samples)
  project?
  (is-active?  project-is-active?  set-project-active!)
  (name        project-name        set-project-name!)
  (samples     project-samples     set-project-samples!))


;; ALIST->PROJECT AND PROJECT->ALIST
;; ----------------------------------------------------------------------------
(define (alist->project input)
  "Turns the association list INPUT into a project record."
  (catch #t
    (lambda _
      (let ((obj (make-project (assoc-ref input 'is-active?)
                               (assoc-ref input 'name)
                               (assoc-ref input 'samples))))
        (when (and (string? (project-samples obj))
                   (string= (project-samples obj) ""))
          (set-project-samples! obj '()))
        obj))
    (lambda (key . args)
      #f)))

(define (project->alist record)
  `((is-active? . ,(project-is-active? record))
    (name       . ,(project-name       record))
    (samples    . ,(project-samples    record))))

;; PROJECT->NTRIPLES
;; ----------------------------------------------------------------------------
(define (project->ntriples input)
  (with-output-to-string
    (lambda _
      (let ((sg  (prefix "http://sparqling-genomics/"))
            (sam (prefix "http://sparqling-genomics/Sample/"))
            (pro (prefix "http://sparqling-genomics/Project/"))
            (rdf (prefix "http://www.w3.org/1999/02/22-rdf-syntax-ns#")))
        (format #t "~a ~a ~a .~%"
                (pro (project-name input))
                (rdf "type")
                (sg "Project"))
        (when (project-samples input)
          (for-each (lambda (sample)
                      (format #t "~a ~a ~a .~%"
                              (sam sample)
                              (sg  "foundIn")
                              (pro (project-name input))))
                    (project-samples input)))))))

;; PROJECTS PERSISTENCE
;; ----------------------------------------------------------------------------
(define (persistence-path username)
  (string-append (www-cache-root) "/" username "/projects.scm"))

(define (load-projects username)
  (catch #t
    (lambda _
      (let ((filename (persistence-path username)))
        (if (file-exists? filename)
          (call-with-input-file filename
            (lambda (port)
              (map alist->project (read port))))
          '())))
    (lambda (key . args)
      #f)))

(define (persist-projects connections username)
  (let ((filename (persistence-path username)))
    (unless (file-exists? (dirname filename))
      (mkdir-p (dirname filename)))
    (call-with-output-file filename
      (lambda (port)
        ;; Before writing to the file under 'port', chmod it so that
        ;; only the user this process runs as can read its contents.
        (chmod port #o600)
        (format port ";; This file was generated by sparqling-genomics.~%")
        (format port ";; Please do not edit this file manually.~%")
        (write (map project->alist connections) port)))))

;; PROJECT-ADD
;; ----------------------------------------------------------------------------
(define (project-add record projects username)
  "Adds a reference to the internal graph for the project RECORD."
  (let ((name    (project-name    record))
        (samples (project-samples record)))
    (cond
     ((string-is-longer-than name (graph-name-max-length))
      (values #f (format #f "The project name cannot be longer than ~a characters."
                         (graph-name-max-length))))
     ((string= name "")
      (values #f (format #f "The project name cannot empty.")))
     ((project-by-name (project-name record) projects)
      (values #f (format #f "There already exists a project with this name.")))
     ((string-contains name " ")
      (values #f (format #f "The project name cannot contain whitespace characters.")))
     (#t (let ((new-state (cons record projects)))
           (persist-projects
            (project-set-as-active! record new-state) username)
           (values #t "The project has been added."))))))

;; PROJECT-EDIT
;; ----------------------------------------------------------------------------
(define (project-edit record projects username)
  "Updates RECORD for which NAME equals the name of an existing record."
  (let ((name    (project-name    record))
        (samples (project-samples record)))
    (cond
     ((string-is-longer-than name (graph-name-max-length))
      (values #f (format #f "The project name cannot be longer than ~a characters."
                         (graph-name-max-length))))
     ((string= name "")
      (values #f (format #f "An empty project name is not allowed.")))
     ((not (project-by-name name projects))
      (values #f (format #f "There is no project with this name.")))
     ((string-contains name " ")
      (values #f (format #f "The project name cannot contain whitespace characters.")))
     (#t (begin
           (persist-projects
            (cons record
                  (delete #f
                          (map (lambda (project)
                                 (if (string= (project-name project) name)
                                     #f
                                     project))
                               projects)))
            username)
           (values #t "The project has been modified."))))))

;; PROJECT-REMOVE
;; ----------------------------------------------------------------------------
(define (project-remove record projects username)
  "Removes the reference in the internal graph for PROJECT."
  (let ((name (if (string? record) record (project-name record))))
    (if (project-is-active? (project-by-name name projects))
        (values #f "Cannot remove the active project.")
        (begin
          (persist-projects
           (filter (lambda (project)
                     (not (string= (project-name project) name)))
                   projects)
           username)
          (values #t (format #f "Removed “~a”." name))))))

;; PROJECT-SET-AS-ACTIVE!
;; ----------------------------------------------------------------------------
(define (project-set-as-active! project projects)
  "Sets PROJECT as the active project."
  (let ((name (if (string? project) project (project-name project))))
    (map (lambda (record)
           (set-project-active! record (string= (project-name record) name))
           record)
         projects)))

;; ALL-PROJECTS
;; ----------------------------------------------------------------------------

(define* (all-projects username #:key (filter #f))
  "Returns a list of project records, applying FILTER to the records."
  (let ((projects (sort (delete #f (load-projects username))
                        (lambda (first second)
                          (string<? (project-name first)
                                    (project-name second))))))
    (if filter
        (map filter projects)
        projects)))

(define (project-by-name name projects)
  (let ((item (filter (lambda (project)
                        (string= (project-name project) name))
                      projects)))
    (if (null? item)
        #f
        (car item))))

(define (active-project username)
  (let ((projects (delete #f
                    (all-projects username
                                  #:filter
                                  (lambda (project)
                                    (if (project-is-active? project)
                                        project
                                        #f))))))
    (if (= (length projects) 1)
        (car projects)
        ;; Upon creating a project, it's set as default.  So when
        ;; there is no active project, that means there is no project at all.
        ;; Automatically create a project when there isn't one.
        (begin
          (project-add (alist->project '((name . "Default"))) '() username)
          (active-project username)))))
