;;; Copyright © 2018  Roel Janssen <roel@gnu.org>
;;;
;;; This program is free software: you can redistribute it and/or
;;; modify it under the terms of the GNU Affero General Public License
;;; as published by the Free Software Foundation, either version 3 of
;;; the License, or (at your option) any later version.
;;;
;;; This program is distributed in the hope that it will be useful,
;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
;;; Affero General Public License for more details.
;;;
;;; You should have received a copy of the GNU Affero General Public
;;; License along with this program.  If not, see
;;; <http://www.gnu.org/licenses/>.

(define-module (www db projects)
  #:use-module (www util)
  #:use-module (www config)
  #:use-module (sparql lang)
  #:use-module (ice-9 format)
  #:use-module (ice-9 receive)
  #:use-module (ice-9 rdelim)
  #:use-module (srfi srfi-1)
  #:use-module (srfi srfi-9)

  #:export (project-add
            project-edit
            project-remove
            all-projects
            project-by-name
            load-projects

            alist->project
            project->alist
            project->ntriples

            make-project
            project-name
            project-samples
            project?

            set-project-name!
            set-project-samples!))

(define %db-projects '())
(define %db-projects-username "")

;; PROJECT RECORD TYPE
;; ----------------------------------------------------------------------------
(define-record-type <project>
  (make-project name samples)
  project?
  (name      project-name       set-project-name!)
  (samples   project-samples    set-project-samples!))


;; ALIST->PROJECT AND PROJECT->ALIST
;; ----------------------------------------------------------------------------
(define (alist->project input)
  "Turns the association list INPUT into a project record."
  (catch #t
    (lambda _
      (let ((obj (make-project (assoc-ref input 'name)
                               (assoc-ref input 'samples))))
        (when (and (string? (project-samples obj))
                   (string= (project-samples obj) ""))
          (set-project-samples! obj '()))
        obj))
    (lambda (key . args)
      #f)))

(define (project->alist record)
  `((name     . ,(project-name     record))
    (samples  . ,(project-samples  record))))

;; PROJECT->NTRIPLES
;; ----------------------------------------------------------------------------
(define (project->ntriples input)
  (with-output-to-string
    (lambda _
      (let ((sg  (prefix "http://rdf.umcutrecht.nl/"))
            (sam (prefix "http://rdf.umcutrecht.nl/Sample/"))
            (pro (prefix "http://rdf.umcutrecht.nl/Project/"))
            (rdf (prefix "http://www.w3.org/1999/02/22-rdf-syntax-ns#")))
        (format #t "~a ~a ~a .~%"
                (pro (project-name input))
                (rdf "type")
                (sg "Project"))
        (for-each (lambda (sample)
                    (format #t "~a ~a ~a .~%"
                            (sam sample)
                            (sg  "foundIn")
                            (pro (project-name input))))
                  (project-samples input))))))

;; PROJECTS PERSISTENCE
;; ----------------------------------------------------------------------------
(define (persistence-path username)
  (string-append (www-cache-root) "/" username "/projects.scm"))

(define (load-projects username)
  (set! %db-projects-username username)
  (catch #t
    (lambda _
      (let ((filename (persistence-path username)))
        (if (file-exists? filename)
          (call-with-input-file filename
            (lambda (port)
              (set! %db-projects
                    (map alist->project (read port)))))
          (set! %db-projects '()))))
    (lambda (key . args)
      #f)))

(define (persist-projects)
  (let ((filename (persistence-path %db-projects-username)))
    (unless (file-exists? (dirname filename))
      (mkdir-p (dirname filename)))
    (call-with-output-file filename
      (lambda (port)
        ;; Before writing to the file under 'port', chmod it so that
        ;; only the user this process runs as can read its contents.
        (chmod port #o600)
        (format port ";; This file was generated by sparqling-genomics.~%")
        (format port ";; Please do not edit this file manually.~%")
        (write (map project->alist %db-projects) port)))))

;; PROJECT-ADD
;; ----------------------------------------------------------------------------
(define (project-add record)
  "Adds a reference to the internal graph for the project RECORD."
  (let ((name    (project-name    record))
        (samples (project-samples record)))
    (cond
     ((string-is-longer-than name (graph-name-max-length))
      (values #f (format #f "The project name cannot be longer than ~a characters."
                         (graph-name-max-length))))
     ((string= name "")
      (values #f (format #f "The project name cannot empty.")))
     ((project-by-name (project-name record))
      (values #f (format #f "There already exists a project with this name.")))
     ((string-contains name " ")
      (values #f (format #f "The project name cannot contain whitespace characters.")))
     (#t (begin
           (set! %db-projects (cons record %db-projects))
           (persist-projects)
           (values #t ""))))))

;; PROJECT-EDIT
;; ----------------------------------------------------------------------------
(define (project-edit record)
  "Updates RECORD for which NAME equals the name of an existing record."
  (let ((name    (project-name    record))
        (samples (project-samples record)))
    (cond
     ((string-is-longer-than name (graph-name-max-length))
      (values #f (format #f "The project name cannot be longer than ~a characters."
                         (graph-name-max-length))))
     ((string= name "")
      (values #f (format #f "An empty project name is not allowed.")))
     ((not (project-by-name name))
      (values #f (format #f "There is no project with this name.")))
     ((string-contains name " ")
      (values #f (format #f "The project name cannot contain whitespace characters.")))
     (#t (begin
           (set! %db-projects
                 (cons record (delete
                               #f (map (lambda (project)
                                         (if (string= (project-name project) name)
                                             #f
                                             project))
                                       %db-projects))))
           (persist-projects)
           (values #t "The project has been modified."))))))

;; PROJECT-REMOVE
;; ----------------------------------------------------------------------------
(define (project-remove project)
  "Removes the reference in the internal graph for PROJECT."
  (let ((name (if (string? project) project (project-name project))))
    (set! %db-projects
          (filter (lambda (record)
                    (not (string= (project-name record) name)))
                  %db-projects))
    (persist-projects)
    (values #t (format #f "Removed “~a”." name))))


;; ALL-PROJECTS
;; ----------------------------------------------------------------------------

(define* (all-projects #:key (filter #f))
  "Returns a list of project records, applying FILTER to the records."
  (if filter
      (map filter %db-projects)
      %db-projects))

(define (project-by-name name)
  (let ((item (filter (lambda (project)
                        (string= (project-name project) name))
                      %db-projects)))
    (if (null? item)
        #f
        (car item))))
