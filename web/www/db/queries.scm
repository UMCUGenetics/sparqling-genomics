;;; Copyright © 2018  Roel Janssen <roel@gnu.org>
;;;
;;; This program is free software: you can redistribute it and/or
;;; modify it under the terms of the GNU Affero General Public License
;;; as published by the Free Software Foundation, either version 3 of
;;; the License, or (at your option) any later version.
;;;
;;; This program is distributed in the hope that it will be useful,
;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
;;; Affero General Public License for more details.
;;;
;;; You should have received a copy of the GNU Affero General Public
;;; License along with this program.  If not, see
;;; <http://www.gnu.org/licenses/>.

(define-module (www db queries)
  #:use-module (www util)
  #:use-module (www base64)
  #:use-module (www config)
  #:use-module (sparql lang)
  #:use-module (ice-9 format)
  #:use-module (ice-9 receive)
  #:use-module (ice-9 rdelim)
  #:use-module (srfi srfi-1)
  #:use-module (srfi srfi-9)
  #:use-module (rnrs bytevectors)

  #:export (query-add
            query-remove
            query-remove-unmarked
            all-queries
            query-by-id
            queries-by-endpoint
            queries-by-project
            query-by-record
            load-queries
            persist-queries

            alist->query
            query->alist

            make-query
            query-id
            query-content
            query-endpoint
            query-execution-time
            query-marked?
            query?

            set-query-id!
            set-query-endpoint!
            set-query-execution-time!
            set-query-content!
            set-query-marked!))


;; QUERY RECORD TYPE
;; ----------------------------------------------------------------------------
(define-record-type <query>
  (make-query id content endpoint execution-time project marked?)
  query?
  (id             query-id             set-query-id!)
  (content        query-content        set-query-content!)
  (endpoint       query-endpoint       set-query-endpoint!)
  (execution-time query-execution-time set-query-execution-time!)
  (project        query-project        set-query-project!)
  (marked?        query-marked?        set-query-marked!))

(define* (generate-unique-query-id queries #:optional (id 1))
  (let ((existing-ids (map query-id queries)))
    (if (member id existing-ids =)
        (generate-unique-query-id queries (1+ id))
        id)))


;; ALIST->QUERY AND QUERY->ALIST
;; ----------------------------------------------------------------------------
(define (alist->query input queries)
  "Turns the association list INPUT into a query record."
  (catch #t
    (lambda _
      (let* ((obj (make-query (assoc-ref input 'id)
                              (assoc-ref input 'content)
                              (assoc-ref input 'endpoint)
                              (assoc-ref input 'execution-time)
                              (assoc-ref input 'project)
                              (assoc-ref input 'marked))))
        ;; Neither the endpoint nor the content may be unset.
        (when (not (query-id obj))
          (set-query-id! obj (generate-unique-query-id queries)))
        (if (and (query-content obj)
                 (query-endpoint obj)
                 (query-project obj))
            obj
            #f)))
    (lambda (key . args)
      #f)))

(define (query->alist record)
  `((id             . ,(query-id record))
    (content        . ,(query-content record))
    (endpoint       . ,(query-endpoint record))
    (execution-time . ,(query-execution-time record))
    (project        . ,(query-project record))
    (marked         . ,(query-marked? record))))


;; QUERIES PERSISTENCE
;; ----------------------------------------------------------------------------
(define (persistence-path username)
  (string-append (www-cache-root) "/" username "/queries.scm"))

(define (load-queries username)
  (catch #t
    (lambda _
      (let ((filename (persistence-path username)))
        (if (file-exists? filename)
            (call-with-input-file filename
              (lambda (port)
                (map (lambda (lst) (alist->query lst '()))
                     (read port))))
            '())))
    (lambda (key . args)
      #f)))

(define (persist-queries queries username)
  (let ((filename (persistence-path username)))
    (call-with-output-file filename
      (lambda (port)
        ;; Before writing to the file under 'port', chmod it so that
        ;; only the user this process runs as can read its contents.
        (chmod port #o600)
        (format port ";; This file was generated by sparqling-genomics.~%")
        (format port ";; Please do not edit this file manually.~%")
        (write (map query->alist queries) port)))))


;; QUERY-ADD
;; ----------------------------------------------------------------------------
(define (query-add record queries username)
  "Adds a reference to the internal graph for the query RECORD."
  (let ((content  (query-content record))
        (endpoint (query-endpoint record))
        (project  (query-project record)))
    (cond
     [(string= content "")
      (values #f (format #f "The query cannot be empty."))]
     [(string= endpoint "")
      (values #f (format #f "The query must have an endpoint."))]
     [(string= project "")
      (values #f (format #f "The query must have a project."))]
     ;; Don't store exact duplicates.
     [(query-by-record record queries)
      (values #f (format #t ""))]
     [#t (begin
           (persist-queries (cons record queries) username)
           (values #t ""))])))


;; QUERY-REMOVE
;; ----------------------------------------------------------------------------
(define (query-remove query queries username)
  "Removes the reference in the internal graph for QUERY."
  (let ((id (cond
             [(string? query)  (string->number query)]
             [(query? query)   (query-id query)]
             [else             query])))
    (persist-queries
     (filter (lambda (record)
               (not (= (query-id record) id)))
             queries)
     username)
    (values #t (format #f "Removed “~a”." id))))


;; QUERY-REMOVE-UNMARKED
;; ----------------------------------------------------------------------------
(define (query-remove-unmarked queries username)
  "Removes queries for which marked? is #f."
  (persist-queries (filter query-marked? queries) username)
  (values #t (format #f "Removed unmarked.")))


;; ALL-QUERIES
;; ----------------------------------------------------------------------------

(define* (all-queries username #:key (filter #f))
  "Returns a list of query records, applying FILTER to the records."
  (if filter
      (map filter (load-queries username))
      (load-queries username)))

(define (query-by-id id queries)
  (let ((item (filter (lambda (query)
                        (= (query-id query) id))
                      queries)))
    (if (null? item)
        #f
        (car item))))

(define (queries-by-endpoint endpoint queries)
  (filter (lambda (query)
            (string= (query-endpoint query) endpoint))
          queries))

(define (queries-by-project project queries)
  (filter (lambda (query)
            (string= (query-project query) project))
          queries))

(define (query-by-record record queries)
  (let ((item (filter
               (lambda (query)
                 (and
                  (string= (query-content query)  (query-content record))
                  (string= (query-endpoint query) (query-endpoint record))
                  (string= (query-project query)  (query-project record))))
               queries)))
    (if (null? item)
        #f
        (car item))))
