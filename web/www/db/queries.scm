;;; Copyright © 2018  Roel Janssen <roel@gnu.org>
;;;
;;; This program is free software: you can redistribute it and/or
;;; modify it under the terms of the GNU Affero General Public License
;;; as published by the Free Software Foundation, either version 3 of
;;; the License, or (at your option) any later version.
;;;
;;; This program is distributed in the hope that it will be useful,
;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
;;; Affero General Public License for more details.
;;;
;;; You should have received a copy of the GNU Affero General Public
;;; License along with this program.  If not, see
;;; <http://www.gnu.org/licenses/>.

(define-module (www db queries)
  #:use-module (www util)
  #:use-module (www base64)
  #:use-module (www config)
  #:use-module (sparql lang)
  #:use-module (ice-9 format)
  #:use-module (ice-9 receive)
  #:use-module (ice-9 rdelim)
  #:use-module (srfi srfi-1)
  #:use-module (srfi srfi-9)
  #:use-module (rnrs bytevectors)

  #:export (query-add
            query-remove
            all-queries
            query-by-id
            queries-by-endpoint
            queries-by-project
            query-by-record
            load-queries
            persist-queries

            alist->query
            query->alist

            make-query
            query-id
            query-content
            query-endpoint
            query-execution-time
            query?

            set-query-id!
            set-query-endpoint!
            set-query-execution-time!
            set-query-content!))

(define %db-queries '())
(define %db-queries-username "")

;; QUERY RECORD TYPE
;; ----------------------------------------------------------------------------
(define-record-type <query>
  (make-query id content endpoint execution-time project)
  query?
  (id             query-id             set-query-id!)
  (content        query-content        set-query-content!)
  (endpoint       query-endpoint       set-query-endpoint!)
  (execution-time query-execution-time set-query-execution-time!)
  (project        query-project        set-query-project!))

(define* (generate-unique-query-id #:optional (id 1))
  (let ((existing-ids (map query-id %db-queries)))
    (if (member id existing-ids =)
        (generate-unique-query-id (1+ id))
        id)))

;; ALIST->QUERY AND QUERY->ALIST
;; ----------------------------------------------------------------------------
(define (alist->query input)
  "Turns the association list INPUT into a query record."
  (catch #t
    (lambda _
      (let ((obj (make-query (assoc-ref input 'id)
                             (assoc-ref input 'content)
                             (assoc-ref input 'endpoint)
                             (assoc-ref input 'execution-time)
                             (assoc-ref input 'project))))
        ;; Neither the endpoint nor the content may be unset.
        (when (not (query-id obj))
          (set-query-id! obj (generate-unique-query-id)))
        (if (and (query-content obj)
                 (query-endpoint obj)
                 (query-project obj))
            obj
            #f)))
    (lambda (key . args)
      #f)))

(define (query->alist record)
  `((id             . ,(query-id record))
    (content        . ,(query-content record))
    (endpoint       . ,(query-endpoint record))
    (execution-time . ,(query-execution-time record))
    (project        . ,(query-project record))))

;; QUERIES PERSISTENCE
;; ----------------------------------------------------------------------------
(define (persistence-path username)
  (string-append (www-cache-root) "/" username "/queries.scm"))

(define (load-queries username)
  (set! %db-queries-username username)
  (catch #t
    (lambda _
      (let ((filename (persistence-path username)))
        (if (file-exists? filename)
            (call-with-input-file filename
              (lambda (port)
                (set! %db-queries (map alist->query (read port)))))
            (set! %db-queries '()))))
    (lambda (key . args)
      #f)))

(define (persist-queries)
  (let ((filename (persistence-path %db-queries-username)))
    (call-with-output-file filename
      (lambda (port)
        ;; Before writing to the file under 'port', chmod it so that
        ;; only the user this process runs as can read its contents.
        (chmod port #o600)
        (format port ";; This file was generated by sparqling-genomics.~%")
        (format port ";; Please do not edit this file manually.~%")
        (write (map query->alist %db-queries) port)))))

;; QUERY-ADD
;; ----------------------------------------------------------------------------
(define (query-add record)
  "Adds a reference to the internal graph for the query RECORD."
  (let ((content  (query-content record))
        (endpoint (query-endpoint record))
        (project (query-project record)))
    (cond
     ((string= content "")
      (values #f (format #f "The query cannot be empty.")))
     ((string= endpoint "")
      (values #f (format #f "The query must have an endpoint.")))
     ((string= project "")
      (values #f (format #f "The query must have a project.")))
     ;; Don't store exact duplicates.
     ((query-by-record record)
      (values #f (format #t "")))
     (#t (begin
           (set! %db-queries (cons record %db-queries))
           (persist-queries)
           (values #t ""))))))

;; QUERY-REMOVE
;; ----------------------------------------------------------------------------
(define (query-remove query)
  "Removes the reference in the internal graph for QUERY."
  (let ((id (cond
             [(string? query)  (string->number query)]
             [(query? query)   (query-id query)]
             [else             query])))
    (set! %db-queries
          (filter (lambda (record)
                    (not (= (query-id record) id)))
                  %db-queries))
    (persist-queries)
    (values #t (format #f "Removed “~a”." id))))


;; ALL-QUERIES
;; ----------------------------------------------------------------------------

(define* (all-queries #:key (filter #f))
  "Returns a list of query records, applying FILTER to the records."
  (if filter
      (map filter %db-queries)
      %db-queries))

(define (query-by-id id)
  (let ((item (filter (lambda (query)
                        (= (query-id query) id))
                      %db-queries)))
    (if (null? item)
        #f
        (car item))))

(define (queries-by-endpoint endpoint)
  (filter (lambda (query)
            (string= (query-endpoint query) endpoint))
          %db-queries))

(define (queries-by-project project)
  (filter (lambda (query)
            (string= (query-project query) project))
          %db-queries))

(define (query-by-record record)
  (let ((item (filter
               (lambda (query)
                 (and
                  (string= (query-content query)  (query-content record))
                  (string= (query-endpoint query) (query-endpoint record))
                  (string= (query-project query)  (query-project record))))
               %db-queries)))
    (if (null? item)
        #f
        (car item))))
