#!@GUILE@ --no-auto-compile
-*- scheme -*-
!#
;;; Copyright Â© 2016, 2017, 2018  Roel Janssen <roel@gnu.org>
;;;
;;; This program is free software: you can redistribute it and/or
;;; modify it under the terms of the GNU Affero General Public License
;;; as published by the Free Software Foundation, either version 3 of
;;; the License, or (at your option) any later version.
;;;
;;; This program is distributed in the hope that it will be useful,
;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
;;; Affero General Public License for more details.
;;;
;;; You should have received a copy of the GNU Affero General Public
;;; License along with this program.  If not, see
;;; <http://www.gnu.org/licenses/>.

(use-modules (ice-9 getopt-long)
             (ice-9 rdelim)
             (rnrs bytevectors)
             (rnrs io ports)
             (sparql driver)
             (srfi srfi-1)
             (sxml simple)
             (system foreign)
             (ldap authenticate)
             (web request)
             (web response)
             (web uri)
             (www base64)
             (www config)
             (www requests)
             (www db connections)
             (www db projects)
             (www db sessions)
             (www pages error)
             (www pages welcome)
             (www pages project-samples)
             (www pages edit-connection)
             (www pages edit-project)
             (www pages)
             (www util))

;; Fibers is not available for Guile 2.0.  When distributions have picked
;; up Guile >2.2, we can remove this variable.
(define %fibers-available?
  (if (resolve-module '(fibers web server) #:ensure #f)
      (begin
        (use-modules (fibers web server))
        #t)
      (begin
        (use-modules (web server))
        #f)))

;; ----------------------------------------------------------------------------
;; CONFIGURATION READER
;; ----------------------------------------------------------------------------
;;
;; The following function(s) parse a configuration file.
;;

(define (read-configuration-from-file filename)
  (catch #t
    (lambda _
      (let* ((sxml-data (call-with-input-file filename
                          (lambda (port)
                            (xml->sxml port #:trim-whitespace? #t))))
             (config (assoc-ref sxml-data 'web-interface)))

        ;; Handle options
        ;; --------------------------------------------------------------------
        (let [(fork?             (assoc-ref config 'fork))
              (address           (assoc-ref config 'bind-address))
              (port              (assoc-ref config 'port))
              (authentication    (assoc-ref config 'authentication))
              (sys-connection    (assoc-ref config 'system-connection))]
          (when (and fork? (> (string->number (car fork?)) 0))
            (set-fork-on-startup! #t))
          (when port
            (set-www-listen-port! (string->number (car port))))
          (when address
            (set-www-listen-address! (car address)))
          (when authentication
            (cond
             ;; LDAP is preferred over single-user authentication.
             [(assoc-ref authentication 'ldap)
              (if (not (ldap-is-available?))
                  (begin
                    (display "Warning: Your configuration specifies an LDAP ")
                    (display "connection, but LDAP is unavailable.  Please ")
                    (display "enable LDAP-support when building ")
                    (display "sparqling-genomics.")
                    (newline))
                  (let ((ldap (assoc-ref authentication 'ldap)))
                    (set-ldap-uri! (car (assoc-ref ldap 'uri)))
                    (set-ldap-organizational-unit!
                     (car (assoc-ref ldap 'organizational-unit)))
                    (set-ldap-domain! (car (assoc-ref ldap 'domain)))
                    (set-ldap-enabled! #t)))]
             ;; Single-user configuration is an alternative to LDAP auth.
             [(assoc-ref authentication 'single-user)
              (let ((user (assoc-ref authentication 'single-user)))
                (if (not user)
                    (begin
                      (display "Warning: Your configuration specifies ")
                      (display "single-user authentication, but your ")
                      (display "configuration is incomplete.")
                      (newline))
                    (if (or (null? (assoc-ref user 'username))
                            (null? (assoc-ref user 'password)))
                        (begin
                          (display "An empty username or password is not ")
                          (display "allowed.")
                          (newline))
                        (let ((username (car (assoc-ref user 'username)))
                              (password (car (assoc-ref user 'password))))
                          (begin
                            (set-authentication-username! username)
                            (set-authentication-password! password)
                            (set-authentication-enabled! #t))))))]))
          (if sys-connection
              (let [(uri         (assoc-ref sys-connection 'uri))
                    (backend     (assoc-ref sys-connection 'backend))
                    (username    (assoc-ref sys-connection 'username))
                    (password    (assoc-ref sys-connection 'password))]
                (cond
                 [(not uri)       (throw 'invalid-system-connection "No URI specified.")]
                 [(null? uri)     (throw 'invalid-system-connection "The URI may not be empty.")]
                 [(not backend)   (throw 'invalid-system-connection "No backend specified.")]
                 [(null? backend) (throw 'invalid-system-connection "Invalid backend specified.")]
                 [(not (member (string->symbol (car backend))
                               (sparql-available-backends)))
                  (throw 'invalid-system-connection "Invalid backend specified.")]
                 [else
                  (set-system-connection! (alist->connection
                                           `((name     . "system-connection")
                                             (uri      . ,(car uri))
                                             (username . ,(if (or (not username)
                                                                  (null? username))
                                                              ""
                                                              (car username)))
                                             (password . ,(if (or (not password)
                                                                  (null? password))
                                                              ""
                                                              (car password)))
                                             (backend  . ,(car backend)))))]))
              (throw 'invalid-system-connection "Missing 'system-connection'."))
          #t)))
    (lambda (key . args)
      (cond
       [eq? key 'invalid-system-connection
            (begin
              (display "Error: There was a problem with the ")
              (display "'system-connection' property:")
              (newline)
              (display (car args))
              (newline)
              (exit 1)
              #f)]
       [else
        (format #t "Error: Couldn't read configuration file (~a: ~a).~%"
                key args)
        #f]))))


;; ---------------------------------------------------------------------------
;; COMMAND-LINE PARSING
;; ---------------------------------------------------------------------------
;;
;; The following section handles command-line arguments.
;;

(define program-options
  '((version             (single-char #\v) (value #f))
    (help                (single-char #\h) (value #f))
    (configuration-file  (single-char #\f) (value #t))))

(define (show-help)
  (for-each (lambda (line) (display line) (newline))
   '("This is sparqling-genomics."
     "  --help                     Show this message."
     "  --version                  Show versioning information."
     "  --configuration-file=ARG   Path to the configuration file."))
  (exit 0))

(define (show-version)
  (display "sparqling-genomics @VERSION@")
  (newline)
  (exit 0))

(define %config (getopt-long (command-line) program-options))

(when (assoc-ref %config 'help)    (show-help))
(when (assoc-ref %config 'version) (show-version))

;; ----------------------------------------------------------------------------
;; RUNNER
;; ----------------------------------------------------------------------------
;;
;; This code runs the web server.
;;

(when (assoc-ref %config 'configuration-file)
  (format #t "Using configuration from ~s.~%"
          (assoc-ref %config 'configuration-file))
  (read-configuration-from-file
   (assoc-ref %config 'configuration-file)))

(when (and (not (ldap-enabled?))
           (not (authentication-enabled?)))
  (format #t "Refused to run without an authentication mechanism.~%")
  (exit 0))

(define (run-sg-server request-handler)
  (if %fibers-available?
      ;; Fibers uses a slightly different syntax for run-server.
      (run-server request-handler
                  #:port (www-listen-port)
                  #:family (www-listen-address-family)
                  #:addr (www-listen-address))
      ;; When Fibers isn't available, fall back to the built-in
      ;; implementation of run-server.
      (run-server request-handler 'http
                  `(#:port ,(www-listen-port)
                    #:addr ,(www-listen-address)))))

(begin
  (catch #t
    (lambda _
      ;; Seed the random number generator.  We use this to generate session IDs.
      ;; To get a secure seed, we use the system call 'getrandom'.
      (let* ((getrandom (pointer->procedure
                         int
                         (dynamic-func "getrandom" (dynamic-link))
                         (list '* size_t uint32)))
             (random-state (make-bytevector 256))
             (random-state-pointer (bytevector->pointer random-state)))
        (do ((bytes 0 (+ bytes (getrandom
                                (make-pointer
                                 (+ bytes
                                    (pointer-address random-state-pointer)))
                                (- 256 bytes) 2))))
            ((= bytes 256))
          #t)
        (set! *random-state* (seed->random-state
                              (base64-encode random-state)))))
    (lambda (key . args)
      ;; If the getrandom syscall is not available, use the default
      ;; 'random-state-from-platform' to seed the pRNG.
      (set! *random-state* (random-state-from-platform))))

  (format #t "sparqling-genomics is running at http://~a:~a~%"
          (inet-ntop (www-listen-address-family)
                     (www-listen-address))
          (www-listen-port))
  (load-sessions)
  (if (fork-on-startup?)
      (let ((pid (primitive-fork)))
        (if (eq? pid 0)
            (with-output-to-file "web.log"
              (lambda _
                (run-sg-server request-handler)
                (primitive-exit)))))
      (run-sg-server request-handler)))
