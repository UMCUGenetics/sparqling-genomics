#!@GUILE@ --no-auto-compile
-*- scheme -*-
!#
;;; Copyright Â© 2016, 2017, 2018  Roel Janssen <roel@gnu.org>
;;;
;;; This program is free software: you can redistribute it and/or
;;; modify it under the terms of the GNU Affero General Public License
;;; as published by the Free Software Foundation, either version 3 of
;;; the License, or (at your option) any later version.
;;;
;;; This program is distributed in the hope that it will be useful,
;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
;;; Affero General Public License for more details.
;;;
;;; You should have received a copy of the GNU Affero General Public
;;; License along with this program.  If not, see
;;; <http://www.gnu.org/licenses/>.

(use-modules (ice-9 getopt-long)
             (ice-9 rdelim)
             (rnrs bytevectors)
             (rnrs io ports)
             (sparql driver)
             (srfi srfi-1)
             (sxml simple)
             (system foreign)
             (ldap authenticate)
             (web request)
             (web response)
             (web uri)
             (www base64)
             (www config)
             (www config-reader)
             (www requests)
             (www db connections)
             (www db projects)
             (www db sessions)
             (www pages error)
             (www pages welcome)
             (www pages project-samples)
             (www pages edit-connection)
             (www pages edit-project)
             (www pages)
             (www util))

;; Fibers is not available for Guile 2.0.  When distributions have picked
;; up Guile >2.2, we can remove this variable.
(define %fibers-available?
  (if (resolve-module '(fibers web server) #:ensure #f)
      (begin
        (use-modules (fibers web server))
        #t)
      (begin
        (use-modules (web server))
        #f)))

;; ---------------------------------------------------------------------------
;; COMMAND-LINE PARSING
;; ---------------------------------------------------------------------------
;;
;; The following section handles command-line arguments.
;;

(define program-options
  '((version             (single-char #\v) (value #f))
    (help                (single-char #\h) (value #f))
    (configuration-file  (single-char #\f) (value #t))))

(define (show-help)
  (for-each (lambda (line) (display line) (newline))
   '("This is sparqling-genomics."
     "  --help                     Show this message."
     "  --version                  Show versioning information."
     "  --configuration-file=ARG   Path to the configuration file."))
  (exit 0))

(define (show-version)
  (display "sparqling-genomics @VERSION@")
  (newline)
  (exit 0))

(define %config (getopt-long (command-line) program-options))

(when (assoc-ref %config 'help)    (show-help))
(when (assoc-ref %config 'version) (show-version))

;; ----------------------------------------------------------------------------
;; RUNNER
;; ----------------------------------------------------------------------------
;;
;; This code runs the web server.
;;

(when (assoc-ref %config 'configuration-file)
  (format #t "Using configuration from ~s.~%"
          (assoc-ref %config 'configuration-file))
  (read-configuration-from-file
   (assoc-ref %config 'configuration-file)))

(when (and (not (ldap-enabled?))
           (not (authentication-enabled?)))
  (format #t "Refused to run without an authentication mechanism.~%")
  (exit 0))

(define (run-sg-server request-handler)
  (if %fibers-available?
      ;; Fibers uses a slightly different syntax for run-server.
      (run-server request-handler
                  #:port (www-listen-port)
                  #:family (www-listen-address-family)
                  #:addr (www-listen-address))
      ;; When Fibers isn't available, fall back to the built-in
      ;; implementation of run-server.
      (run-server request-handler 'http
                  `(#:port ,(www-listen-port)
                    #:addr ,(www-listen-address)))))

(begin
  (catch #t
    (lambda _
      ;; Seed the random number generator.  We use this to generate session IDs.
      ;; To get a secure seed, we use the system call 'getrandom'.
      (let* ((getrandom (pointer->procedure
                         int
                         (dynamic-func "getrandom" (dynamic-link))
                         (list '* size_t uint32)))
             (random-state (make-bytevector 256))
             (random-state-pointer (bytevector->pointer random-state)))
        (do ((bytes 0 (+ bytes (getrandom
                                (make-pointer
                                 (+ bytes
                                    (pointer-address random-state-pointer)))
                                (- 256 bytes) 2))))
            ((= bytes 256))
          #t)
        (set! *random-state* (seed->random-state
                              (base64-encode random-state)))))
    (lambda (key . args)
      ;; If the getrandom syscall is not available, use the default
      ;; 'random-state-from-platform' to seed the pRNG.
      (set! *random-state* (random-state-from-platform))))

  (format #t "sparqling-genomics is running at http://~a:~a~%"
          (inet-ntop (www-listen-address-family)
                     (www-listen-address))
          (www-listen-port))
  (load-sessions)
  (if (fork-on-startup?)
      (let ((pid (primitive-fork)))
        (if (eq? pid 0)
            (with-output-to-file "web.log"
              (lambda _
                (run-sg-server request-handler)
                (primitive-exit)))))
      (run-sg-server request-handler)))
